      SUBROUTINE SRTIND(A,N)
      USE lispa0, ONLY : lures
      IMPLICIT NONE

      INTEGER (kind=4) :: N,A(N,2)

!***  SUPPLIED BY DON CALAHAN

!   PARTITION SORTING ALGORITHM
! REFERENCE COLLECTED ALGORITHMS OF THE ACM - 63,64,65

      INTEGER (kind=4) :: IHIGH(32), ILOW(32),NSEGS,I,IL,IH,ISEPX,&
     &                    ISEP(2),IXL,IXH,IT(2)
! INITIALIZE
      DO I = 1,N
        A(I,2)=I
      END DO
      NSEGS = 1
      IL = 1
      IH = N
! IF NO ELEMENTS IN THIS SEGMENT DO NOTHING
   10 IF (IL >= IH) GO TO 80
! CHOOSE ISEP (SEPARATION ENTRY):
!  MAKE A(IL) <= A((IL+IH)/2) <= A(IH) BY INTERCHANGE
!  SET ISEP= A((IL+IH)/2)
   20 ISEPX = (IH + IL) / 2
      ISEP = A(ISEPX,:)
! IXL IS LOWER SEGMENT INDEX (CURRENT)
      IXL = IL
! MAKE A(IL) <= A(ISEPX)
      IF (A(IL,1) <= ISEP(1)) GO TO 30
      A(ISEPX,:) = A(IL,:)
      A(IL,:) = ISEP
      ISEP = A(ISEPX,:)
! IXH IS HIGHEST SEGMENT INDEX (CURRENT)
   30 IXH = IH
! MAKE A(IH) >= A(ISEPX)
      IF (A(IH,1) >= ISEP(1)) GO TO 50
      A(ISEPX,:) = A(IH,:)
      A(IH,:) = ISEP
      ISEP = A(ISEPX,:)
! MAKE A(IL) <= A(ISEPX)
      IF (A(IL,1) <= ISEP(1)) GO TO 50
      A(ISEPX,:) = A(IL,:)
      A(IL,:) = ISEP
      ISEP = A(ISEPX,:)
      GO TO 50
! EXCHANGE LOW PART ENTRY WHICH IS GREATER THAN SEPARATOR WITH HIGH
! PART ENTRY WHICH IS LESS THAN OR EQUAL TO THE SEPARATOR VALUE.
   40 IT = A(IXH,:)
      A(IXH,:) = A(IXL,:)
      A(IXL,:) = IT
! MOVE DOWN UPPER SEGMENT AS FAR AS WE CAN
   50 IXH = IXH - 1
      IF (A(IXH,1) > ISEP(1)) GO TO 50
! MOVE UP LOWER SEGMENT AS FAR AS WE CAN
   60 IXL = IXL + 1
      IF (A(IXL,1) < ISEP(1)) GO TO 60
! NOTHING TO DO IF BOTH SEGMENTS HAVE AT MOST ONE ENTRY IN COMMON
      IF (IXL <= IXH) GO TO 40
! IF BOTH SEGMENTS OVERLAP THEN THEY ARE SEPARATED
! IN THIS CASE CONTINUE WITH SHORTER SEGMENT, STORING THE LONGER
      IF (IXH - IL <= IH - IXL) GO TO 70
! LOWER SEGMENT LONGER, CONTIN WITH UPPER AFTER SAVING LOWER
      ILOW(NSEGS) = IL
      IHIGH(NSEGS) = IXH
      IL = IXL
      NSEGS = NSEGS + 1
      GO TO 90
! UPPER SEGMENT LONGER, CONTIN WITH LOWER AFTER SAVING UPPER
   70 ILOW(NSEGS) = IXL
      IHIGH(NSEGS) = IH
      IH = IXH
      NSEGS = NSEGS + 1
      GO TO 90
! GET ANOTHER SEGMENT FOR PROCESSING IF THERE ARE ANY MORE
   80 NSEGS = NSEGS - 1
      IF (NSEGS == 0) GO TO 130
      IL = ILOW(NSEGS)
      IH = IHIGH(NSEGS)
! CONTINUE TO SEGMENT AS LONG AS LENGTH IS GREATER THAN 11
   90 IF (IH - IL >= 11) GO TO 20
      IF (IL == 1) GO TO 10
      GO TO 110
! SORT ELEMENTS WITHIN SEGMENT BY INTERCHANGE OF ADJACENT PAIRS
  100 IL = IL + 1
  110 IF (IL == IH) GO TO 80
      ISEP = A(IL + 1,:)
      IF (A(IL,1) <= ISEP(1)) GO TO 100
      IXL = IL
  120 A(IXL + 1,:) = A(IXL,:)
      IXL = IXL - 1
      IF (ISEP(1) < A(IXL,1)) GO TO 120
      A(IXL + 1,:) = ISEP
      GO TO 100
  130 CONTINUE
!
!     verification for the node labels
!
      DO i = 1,n-1
        IF (a(i,1) == a(i+1,1)) THEN
          WRITE(lures,*,ERR=9999)' Two nodes have the same label',a(i,1)
          CALL runen3(' SRTIND: 2 nodes have the same labl')
        ENDIF
      ENDDO

      RETURN
 9999 CALL runen2('')
      END SUBROUTINE SRTIND
