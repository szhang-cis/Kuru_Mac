#!/usr/bin/python
# -*- coding: utf-8 -*-

from multiprocessing import Process, cpu_count
import os, shutil, time, sys
import subprocess, errno
import daemon, socket, threading, select, datetime
from vulcan import Vulcan

class InfoServer(threading.Thread):
    def __init__(self, pid):
        super(InfoServer, self).__init__()
        if not os.path.exists(os.path.expanduser(os.path.join("~", ".vulcanSock"))):
                os.mkdir(os.path.expanduser(os.path.join("~", ".vulcanSock")))
        self.server_address = os.path.expanduser(os.path.join("~", ".vulcanSock", "vulcan-" + str(pid) + ".sock"))
        try:
            os.unlink(self.server_address)
        except OSError:
            if os.path.exists(self.server_address):
                raise
        self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self.alive = True
        self.pid = pid
        self.max_iter = 0
        self.itera = 0
        self.max_interval = 0
        self.interval = 0
        self.case_name = ""
        self.status = 0
        self.launch_date = 0
        self.elapsed = 0
        self.last_step_time = 0
        self.data_ready = False
    def run(self):
        self.sock.bind(self.server_address)
        self.sock.listen(5)
        while self.alive:
            (conn, address) = self.sock.accept()
            string = self.build_send_string()
            l = 0
            while l < len(string):
                sent = conn.send(string[l:])
                if sent == 0:
                    raise RuntimeError("Connection broken")
                l += sent
            while True:
                readable, writable, exceptional = select.select((conn,),(conn,),(conn,))
                for s in readable:
                    data = s.recv(10)
                    if data:
                        if data[0] == "K":
                            raise
                for s in writable:
                    if self.data_ready:
                        self.data_ready = False
                        l = 0
                        while l < len(self.outbuffer):
                            sent = s.send(self.outbuffer[l:])
                            if sent == 0:
                                raise RuntimeError("Connection broken")
                            l += sent
                for s  in exceptional:
                    pass        
    def stop(self):
        self.alive = False
    def baseInfo(self, max_iter, max_interval, case_name, launch_date):
        self.case_name = case_name
        self.max_iter = max_iter
        self.max_interval = max_interval
        self.launch_date = launch_date
    def newInfo(self, itera=False, interval=False, status=False, last_step_time=False):
        if last_step_time is not False:
            self.last_step_time = last_step_time
        if itera is not False:
            self.itera = itera
        if interval is not False:
            self.interval = interval
        if status is not False:
            self.status = status
        self.outbuffer = self.build_update_string()
        self.data_ready = True
    def build_send_string(self):
        #Format NP(PID 6 digit)I(maxiter 4 digit)N(maxinterval 3 digit)D(datetime Y-M-D H:M:S)C(casename 50 characters)
        return 'NP{pid:06}I{maxiter:04}N{maxinterval:03}D{datetime:%Y-%m-%d %H:%M:%S}C{casename:<50}'.format(pid=self.pid,maxiter=self.max_iter,maxinterval=self.max_interval,datetime=self.launch_date,casename=self.case_name)
    def build_update_string(self):
        # Format UI(iternum 4 digit)N(intervalnum 3 digit)S(s in 0 running, 1 error, 2 diverged, 3 converged)E(last step time in seconds 7 digits)
        string = 'UI{iternum:04}N{intervalnum:03}S{status}E{laststime:07}'.format(iternum = self.itera,intervalnum=self.interval,status=self.status,laststime=self.last_step_time)
        return string
    def address(self):
        return self.server_address

    def runold(self):
        if self.allGood:
            self.env.update(self.env_temp) 
            self.env.update(self.env_res) 
            self.env.update(self.env_dat)
            #print self.env['FOR060']
            p = subprocess.Popen(self.vulcan_exec, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=self.env)
            print " "
            print "Ejecutando Vulcan Script PID:", os.getpid()
            print "Ejecutando Vulcan-m.O2   PID:", p.pid
            server = InfoServer(p.pid)
            now = datetime.datetime.now()
            max_iter, max_interval, case_name = (10,20,"Hola")
            server.baseInfo(max_iter, max_interval, case_name, now)
            server.start()
            p.wait()
            for i in range(10):
                server.newInfo(itera = i)
                time.sleep(2)
            server.stop()
            print "Vulcan se terminÃ³ de ejecutar"
            self.stdout = p.stdout
            self.stderr = p.stderr
            for key, item in self.env_temp.iteritems():
              try:
                 os.remove(item)
              except OSError:
                 continue
            os.remove(server.address())
            self.returnValue = p.returncode
            tim = open(self.env['FOR120'],'w')
            err = open(self.env['FOR120'][:-4]+".err",'w')
            tim.writelines(self.stdout.readlines())
            err.writelines(self.stderr.readlines())
            tim.flush()            
            tim.close()
            err.flush()
            err.close()
        else:
            print "No se ejecuta vulcan error de parametros"



def main():
    if len (sys.argv) < 2:
        print "Uso: vulcan tipo_problema archivo_dat (con extension)"
        print "tipo_problema -> tfms"
        sys.exit(1)
    filename = os.path.abspath(sys.argv[2])
    dat_directory = os.path.dirname(filename)
    filename = os.path.splitext(os.path.basename(filename))[0] #Obtiene el nombre del archivo sin extension si
    abs_file_list = []
    for arg in sys.argv[1:]:
        if os.path.splitext(arg)[1] == ".dat":
            abs_file_list.append(os.path.abspath(arg))
        else:
            abs_file_list.append(arg)
    try:
        import setproctitle
        setproctitle.setproctitle("Vulcan-"+filename)
    except:
        pass
    with daemon.DaemonContext(stdout=sys.stdout,stderr=sys.stderr):
        worker(filename, abs_file_list)
        
        
def worker(filename, args):        
      a = Vulcan(os.path.expanduser(os.path.join("~", "scratch")), args)
      a.run()

if __name__ == "__main__":
    main()